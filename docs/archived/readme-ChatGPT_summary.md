ShowNotes Web App – Development Status Report

1. Purpose and Core Functionality of ShowNotes

ShowNotes is a Flask-based web application that helps users explore television shows, character storylines, and the overlap of actors across different series. Its core features include:
	•	Spoiler-Aware Character Summaries: Users can obtain character summaries that are conscious of how far the user has watched (to avoid spoilers). These summaries include a character bio, notable quotes, and a “Significant Relationships” section, among other structured details ￼ ￼. The summaries are generated using OpenAI (GPT-4) based on prompt templates and can be limited to a specific season/episode to control spoilers.
	•	Relationship Mapping and Actor Overlap: The app can compare two shows or movies to find overlapping actors. A “Compare” feature identifies shared cast members between two titles, highlighting which actors appear in both and summarizing their roles. This helps users discover connections between series (hence the former name “Venn-Cast”). It also provides enriched actor details such as known-for roles and links to external databases.
	•	Interactive Character Chat: ShowNotes offers a chat-style interface where users can “chat” with a fictional character. The system uses GPT-4 to role-play the character, responding in the character’s voice and personality. This feature enables a fun, in-character Q&A experience (e.g. asking Walter White about Breaking Bad).
	•	Integration with TV Metadata Services: The app integrates with external services for data. It uses the TMDB API to fetch show information, cast lists, images (posters/backdrops), and descriptions. It also interfaces with Sonarr (a local TV library manager) to retrieve upcoming episode schedules and with Plex via webhooks to track what a user has recently watched. For example, the app can log a Plex “viewed episode” event and mark a show as the “Currently Watching” title for the user. This integration lays groundwork for automatically adjusting spoiler levels based on watch history.
	•	Spoiler Tracking and Summaries: Using the data from Plex or user input, ShowNotes can limit summaries to certain episodes. The design is such that if a user has only watched up to Season 2, the generated summary will not include events beyond that point. The app maintains a lightweight user watch log and a “current watch” record in SQLite to support this spoiler-aware functionality.

Overall, ShowNotes serves as a personal companion for TV enthusiasts – providing enriched character notes, cross-show insights, and interactive features while respecting the user’s progress in each series ￼. It combines data from local services (Sonarr/Plex) and public APIs (TMDB, OpenAI) to create a unique, spoiler-sensitive exploration tool.

2. Current Codebase Structure and Key Modules

The project is organized as a typical Flask application with a clear separation of concerns between routing, logic, templates, and static resources ￼. Below is an overview of the key components and how they work together:
	•	Flask App Factory and Blueprint: The application factory is defined in app/__init__.py as create_app(). This function initializes the Flask app, registers the main application blueprint, and configures any Jinja filters. All routes are grouped under a single Blueprint called main (defined in app/routes.py), which is registered with the app on creation. This blueprint encapsulates both user-facing routes and admin/test routes. The run.py script at the project root simply creates the app via create_app() and runs the development server.
	•	Routing Layer (app/routes.py): This module contains all Flask route definitions for the web interface. It handles page requests and API endpoints:
	•	User-facing pages: the home page (/) showing the “Currently Watching” section and recent shows, a compare results page (/compare), show detail pages (/show/<title>), character summary pages (/character-summary), and the character chat page (/chat-as-character). These routes gather necessary data (from the database or external APIs via utils) and render Jinja2 templates. For example, the character summary route will fetch or generate the summary then serve character_summary.html with the results.
	•	Autocomplete API endpoints: e.g. /autocomplete/shows and /autocomplete/characters return JSON suggestions for search fields. Currently these use the local SQLite database to suggest show titles and character names based on existing records.
	•	Integration webhooks and APIs: routes like /plex-webhook handle incoming POST requests from Plex Media Server when an episode is watched, updating the database log. Another route, /calendar/full, is intended to serve upcoming episode data (fetched from Sonarr) as JSON for a calendar view.
	•	Admin and utility routes: prefixed under /admin/*. These include pages to review data logs (/admin/usage, /admin/summaries, /admin/webhook-log, etc.) and test endpoints (e.g. /admin/test-webhook, /admin/test-character-summary) for development and debugging. For instance, /admin/api-usage queries the api_usage table and renders an usage report page, and /admin/summaries lists recent cached character summaries from the database for review.
	•	Utility Logic (app/utils.py and helpers): The core logic of the application resides in utils.py. This module provides functions for external API calls and data processing, which are invoked by the routes:
	•	TMDB integration: Functions like search_tmdb() query The Movie Database API for shows or movies by name. get_cast() retrieves the cast list for a given show or movie ID (including episode counts for TV roles). These enable features such as searching for a show and listing its characters/actors. There are also helpers to get additional info like get_known_for() (top known roles for an actor) and get_show_backdrop() to fetch a show’s backdrop image URL.
	•	OpenAI integration: The app uses OpenAI’s API via a client to generate content. For example, get_character_summary() sends a prompt to GPT-4 to obtain a detailed character summary, and chat_as_character() crafts a prompt to have GPT-4 respond in the voice of a given character. The API key is loaded from environment variables (.env file) on startup.
	•	Prompt construction and parsing: Instead of hardcoding long prompts in the route code, ShowNotes defines reusable prompt templates in app/prompt_builder.py. This module builds structured prompts for different tasks (character summary, quotes list, relationships list) with consistent markdown sections. After the AI returns a response, utils.py provides parsing functions (e.g. parse_character_summary()) to extract structured data (like lists of traits or events) from the formatted text. This parsed data is used to format the output neatly for display.
	•	Data caching and database access: The application uses a SQLite database (data/shownotes.db) to cache results and track usage. Utility functions handle saving and retrieving this data. For example, save_character_summary_to_db() stores a generated summary (raw text and parsed fields) into the character_summaries table, and get_cached_summary() checks if a summary for that character/show/episode limit already exists to avoid redundant API calls. Similarly, save_top_characters() and get_top_characters() maintain a list of main characters for each show in the database. The database is also used to log OpenAI API usage (api_usage table) and events like Plex webhooks or search queries.
	•	Ancillary helpers: There are minor utility functions such as get_reference_links() which prepares external reference URLs (Wikipedia, IMDb, etc.) for a given show or actor, and some debugging routes that utilize utility calls to test the system.
	•	Templates and Static Files: The templates/ directory holds Jinja2 templates for the HTML pages (user interface). Key templates include:
	•	index.html – the home page, showing the “Currently Watching” show (with banner/poster if available) and a list of top characters, as well as a form to compare two shows.
	•	show.html – displays details for a single show, including seasons and main characters.
	•	character_summary.html – shows the formatted character summary with sections like Traits, Relationships, etc.
	•	chat_as_character.html – provides a chat interface for the character conversation feature.
	•	Several partials and admin pages (e.g., admin_menu.html for the sidebar, api_usage.html to list API usage records, admin_webhook_log.html for webhook events, etc.). These admin pages are marked as work-in-progress.
The static files (static/ folder) contain CSS and JavaScript. Notably, a custom JS autocomplete.js implements the dynamic suggestion dropdowns for search fields, calling the Flask autocomplete endpoints via AJAX. CSS files define the layout and any custom styling (including a calendar.css intended for the calendar view). The presence of static/img/default-poster.png suggests a fallback image is used when a show’s poster is not available.
	•	Database Schema: Although no ORM is used, the code creates and uses several tables in SQLite. Key tables observed in the code include:
	•	shows and show_metadata: store high-level info about shows (title, TMDB id, description, poster/backdrop paths).
	•	season_metadata: stores info on seasons of shows.
	•	top_characters: stores main characters for each show (character name, actor, and episode count).
	•	character_summaries: caches the generated character summaries (with fields for character, show, season/episode limit, the raw summary text, and parsed JSON for traits/events/relationships/quote, plus a timestamp).
	•	api_usage: logs each OpenAI API call with token counts and cost.
	•	current_watch: tracks the latest episode watched per user (used for “Currently Watching” logic).
	•	webhook_log: records every Plex webhook event received (each view event).
	•	autocomplete_logs: records when a user selects an autocomplete suggestion (for analytics on search terms).
These tables are created on the fly if not present (for example, the Plex webhook route ensures current_watch and webhook_log tables exist). An initialization route (/admin/init-db) can also set up basic tables like api_usage and metadata tables. The database file is packaged with the app (under data/shownotes.db), and a script scripts/init_db.py is provided, suggesting the development workflow includes preparing the schema and possibly pre-loading some data.

In summary, the codebase is structured into a clear MVC-like pattern: Routes (controllers) handle HTTP requests and coordinate work, Utils/PromptBuilder (models & logic) perform data fetching and AI interactions, and Templates/Static files (views) render the results to the user. The README’s file structure and developer notes confirm this separation – for example, all OpenAI and summary logic resides in utils.py, and prompt templates can be adjusted in one place ￼. This modular design aligns with the intended architecture and makes it easier to extend the app’s capabilities.

3. Status of Outstanding TODO Items

Using the provided todo.md list as a reference, the current codebase implements some of the planned features while others remain incomplete or work-in-progress. Below is a breakdown of each major to-do item (excluding unrelated receipt-processing tasks) and its status in the current development state:
	•	Fix create_app() crashes and import issues: Completed. The app factory (create_app) is present and functional. In the current code, create_app() correctly sets up the Flask app and registers the main blueprint without errors. All necessary modules (routes, utils, etc.) are imported within this function, so the earlier crashing issue appears resolved. The server starts up via run.py using this factory pattern, indicating this task has been addressed.
	•	Add TMDB autocomplete for show and character search inputs: Partially implemented. Autocomplete functionality exists, but it currently draws from the local database rather than live TMDB queries. The front-end has JavaScript that calls /autocomplete/shows and /autocomplete/characters endpoints as the user types. Those endpoints are implemented in Flask and return JSON suggestions, but they simply query the app’s own SQLite tables for matching titles or character names. There is no direct TMDB API call for autocompletion yet. In practice, this means the autocomplete will only suggest shows that have been added to the local database (e.g., via prior searches or metadata fetches). Expanding this to query TMDB’s vast library in real-time is still outstanding.
	•	Enable Plex webhook integration to track watched episodes and adjust spoiler levels: Substantially implemented (needs refinement). The code includes a working Plex webhook receiver at the route /plex-webhook. When Plex sends a “media scrobble” (watch) event, the app extracts the show title, season, episode, and user from the payload and logs it. It updates a current_watch table (to record the user’s latest watched episode) and appends an entry to a webhook_log table. This satisfies the tracking portion of this task. The adjusting of spoiler levels based on this data is only partially realized: the app’s design supports spoiler limits (the character summary generator always considers a season/episode cutoff), and the “Currently Watching” show from Plex is used as the default context on the homepage. However, there is no dynamic mechanism yet to automatically apply a user’s watch progress to every query – for example, a user’s Plex history is not yet used to auto-populate the season/episode fields when requesting a character summary. Implementing that (perhaps by looking up the current_watch entry per user and using it to set default spoiler limits) would complete this item. In summary, the webhook integration exists and logs data (the heavy lifting is done), but using that data to seamlessly manage spoiler settings in the UI is an open task.
	•	Integrate Sonarr calendar with episode hover previews and filters (premieres, finales, etc.): In progress (not fully functional). The intention is to display an upcoming episode calendar (likely using a library like FullCalendar) showing upcoming air dates from Sonarr. The codebase has a stub for this integration: an endpoint /calendar/full is defined to return JSON events derived from Sonarr’s calendar API. In the provided code, this function calls fetch_sonarr_calendar(days=7) to get the next week of episodes. However, the implementation of fetch_sonarr_calendar is either missing or not properly integrated (the app/sonarr_calendar.py file contains a standalone example of fetching Sonarr data, but it isn’t wired into the main app). Consequently, the calendar feature is incomplete – the front-end page calendar.html and associated hover-preview logic are not fully realized. There is also no evidence yet of filtering highlights like premieres/finales in the code. This task remains outstanding, needing both back-end completion (integrating the Sonarr API call and populating the template) and front-end work (displaying the calendar and adding hover tooltips or filters for special episodes).
	•	Build OpenAI prompt enrichment system (title, description, quantity, mass, etc.): Not implemented (needs clarification). This item appears to refer to a system for enhancing data using OpenAI – possibly taking basic inputs (like a title or item description with some numeric attributes) and generating richer details (for instance, filling in missing fields such as quantity or weight). However, within the context of ShowNotes’ codebase, there is no feature that directly corresponds to “quantity” or “mass”, which suggests this item might be unrelated to the core TV show functionality. It may have been an experimental idea or part of another feature set. The current code does not have any functions dealing with generic “prompt enrichment” for titles/descriptions outside of the TV show domain. As it stands, this to-do is not addressed in the code, and its exact requirements are unclear. It likely needs further clarification or may belong to a separate scope, as no evidence of it exists in the ShowNotes app logic.
	•	Track and display OpenAI API usage (by date, endpoint, token count, cost): Partially implemented. The foundation for this feature is present. Every time the app calls the OpenAI API to generate a summary or a chat reply, it records the usage in the SQLite database. Specifically, entries are added to an api_usage table with fields for prompt tokens, completion tokens, total tokens, model, and a timestamp. In the character summary generation code, a cost estimate is also calculated and stored. To display this data, an admin route /admin/api-usage is implemented, which retrieves recent usage records and renders an API usage summary page. The template api_usage.html shows a table of these records (likely including date, model, and cost for each call). What remains to be done is any advanced analysis or filtering (e.g. summarizing by date or providing totals). Currently it’s a basic log view. The task item also mentions tracking by endpoint – the code mostly uses a single model (GPT-4) for now, so differentiation isn’t an issue, but if multiple models/endpoints are used, the logging and display might need extension. In summary, basic usage tracking and display are in place, and the admin page for it is in development (functional but minimal). Further enhancements (like charts or export features) are still possible improvements.
	•	Admin Dashboard – Recent OpenAI queries: Not implemented. There is no interface yet that shows the actual queries/prompts sent to OpenAI or a list of recent query texts. The “recent OpenAI queries” likely refers to displaying the content of prompts or the characters/shows recently asked about. The code does store the last generated summaries and logs usage, but it does not store prompt texts or user questions in a readily displayable form. As a result, no page currently lists recent prompts or questions. This sub-task remains open; implementing it might involve logging prompt content or at least the summary requests (character name, show, and cutoff) and then presenting those on an admin page.
	•	Admin Dashboard – API usage summary: Partially implemented. As noted above, the /admin/api-usage page serves as a usage summary, listing recent API calls and their token/cost details. This covers the basic requirement of an API usage overview. If the intent was a more graphical summary (e.g., totals per day, cost over time), that part is not done yet. For now, the admin can manually review the log of recent calls on that page.
	•	Admin Dashboard – JSON route links for Shortcuts: Not implemented (unclear). The idea here seems to be providing easily accessible API endpoints (returning JSON) for integration with external tools or automation (for example, iOS Shortcuts or other clients). In the current state, while the app does have JSON endpoints (like the autocomplete and calendar APIs), there is no dedicated page listing them or specific routes tailored for external consumption aside from what the web UI uses internally. The admin menu does not list “JSON links” presently. This item would require identifying which data outputs to expose and creating a dashboard or documentation for them. As of now, it remains unaddressed.
	•	Admin Dashboard – Logs of uploaded or parsed data: Partially implemented. ShowNotes does capture certain logs, specifically the autocomplete selections and webhook events, and provides admin pages to view them. For example, /admin/autocomplete-log shows recent search terms selected by users, and /admin/webhook-log shows the history of Plex webhook events (episodes watched). These pages indicate that some logging of “parsed data” is already in place and viewable. However, if “uploaded or parsed data” refers to other types of data (perhaps file uploads or the receipt parsing mentioned in excluded items), those are not implemented in the TV show context. For the core app, the logs available cover the main interactions. There isn’t a single unified dashboard that aggregates all logs; instead, there are individual pages per log type accessible from the Admin Tools menu. Thus, while the infrastructure for logging exists, the task of a consolidated admin logging dashboard could be considered ongoing.
	•	Finalize reusable prompt templates (summary, relationships, arcs, quotes): In progress. The codebase has made significant progress on this item. The prompt templates for character summaries, quotes, and relationships are defined in prompt_builder.py. They produce consistent markdown sections (for traits, key events, etc.) which the parser expects. This indicates that much of the prompt template work is done. The mention of “arcs” suggests possibly adding a section for character story arcs or development over time, which is not explicitly in the current template. (There is a section for “Motivations & Inner Conflicts” and “Themes & Symbolism,” but not a separate “Arcs” section by name.) It appears the template can still be expanded or tuned, and the README encourages that prompts can be adjusted easily ￼ ￼. In summary, the foundation of reusable prompts is implemented, but there may be some final refinements or additional templates (like story arcs) that remain to be added to fully satisfy this task.
	•	Add prompt-based regeneration with spoiler limits (e.g., “up to Season 2”): Not yet implemented in the UI. While the back-end supports generating a summary limited to a certain season/episode, currently the user must input those limits manually (or they default to Season 1 Episode 1). The to-do implies a feature where a user could easily regenerate or adjust a summary to a different cutoff (for instance, after watching more episodes, update the summary to include up to Season 3). The interface does not yet provide a one-click “regenerate up to X” option. There is no button on the character summary page to redo the summary with a higher spoiler threshold; the user would have to resubmit the form with new parameters. Thus, this remains an outstanding UI improvement – adding controls to quickly regenerate or update summaries as the spoiler limit changes.
	•	Enable structured caching of OpenAI results (by character, episode, etc.): Completed. The app already implements caching of AI results in a structured way. Each character summary generated is saved in the character_summaries table along with the character name, show, and the season/episode limits that were used. When a user requests a summary, the code checks for an existing entry for that character and spoiler level before calling the API. This prevents repeated API calls for the same query. The caching is structured by character and episode context (and can store multiple versions for different cutoff points). Therefore, this to-do is essentially done. Future enhancements could include a more sophisticated cache invalidation or management, but the core functionality (avoid redundant OpenAI calls by caching outputs per character/show/episode combination) is in place.
	•	Add ability to regenerate summaries with new context or version tags: Not implemented. Currently, if a summary exists in the cache, the app will simply retrieve it and not call OpenAI again for that character/episode scope. There isn’t a user-facing mechanism to request a fresh version (for example, if the user believes the summary is incomplete or wants a different “take” on it). There are no “version tags” or multiple saved versions – the database keeps the last result per character context (older ones would be overwritten or simply not retrieved except the latest by timestamp). Implementing this feature would require allowing parallel storage of multiple summary versions and giving the user a choice to generate a new one (perhaps with a different “context” or prompt variation) despite a cached one existing. As of now, that capability is absent. The admin test route /admin/test-character-summary always triggers a new generation, but end-users have no such option in the UI. This remains an open enhancement for the future.
	•	Display poster/banner in “Currently Watching” section: Partially implemented. The intention is to show a nice visual (poster or banner image) for the show the user is currently watching (tracked via Plex). In the code, the index page does attempt to display an image for the current show. It first tries to find a season-specific banner/poster for the current season, and falls back to a show poster if available. The HTML in index.html uses an <img> tag to show either a season banner (using TMDB’s images) or the show’s poster in the “Currently Watching” card. However, there are some inconsistencies in how the data is retrieved (for example, the code’s logic to get the poster may not always succeed due to how show_metadata is queried). The feature is not entirely reliable yet – it may show the image if all data is present, but it’s possible it fails silently in some cases. There is also no explicit toggle of banner vs poster; it tries one then the other. In summary, the framework to display a show image in the “Currently Watching” section is in place, but it may need debugging or refinement to ensure the correct image always displays. As a result, this task is nearly done but might not be fully verified (it should be tested and adjusted if the wrong fields are used).
	•	Fix duplicate characters showing in the main character list: Completed. The main character list (e.g., on the show detail page or homepage) was likely showing duplicates if a character appeared multiple times in the source data. The current code explicitly handles this by filtering unique characters. For instance, on the index page, after fetching the top characters, it removes duplicates by character name/actor pair before rendering. This indicates the duplicate listing bug has been fixed. Testing the app should show that each character appears only once in the lists. Therefore, this to-do item has been addressed in the current code.
	•	Show calendar with upcoming Sonarr episodes: Not completed. While related to the Sonarr integration item above, this specifically refers to a user-visible calendar UI. There is a calendar.html template and a route to provide data, but as noted, the integration isn’t finished. The calendar page is not linked prominently in the UI yet (for example, no navigation button for it is present in the main interface), and the data feed may not function. The to-do likely envisions a calendar view (possibly with colored indicators for days, etc.). At this time, delivering a working calendar to the user remains undone. Finishing this requires both the back-end data integration with Sonarr and front-end JavaScript to render a calendar (perhaps using a library like FullCalendar or a custom visualization). This task is outstanding.
	•	Add modals for character previews when clicked from list: Not implemented. Currently, clicking a character in the list (e.g., on the homepage’s character list or a show page) will likely navigate to the full character summary page. The idea in this to-do is to instead (or additionally) show a quick preview in a modal window when a character’s name is clicked, so the user can get a brief summary without leaving the page context. There is no code in place for such modals – no JS event handlers or modal HTML snippets for character previews exist yet. Implementing this would involve front-end work (JavaScript to fetch either an existing summary snippet via AJAX or to display cached info) and possibly additional routes or use of the cached summary. As of now, clicking a character simply triggers a normal page load. So this feature is not done.
	•	Show red/green calendar days based on usage vs. generation (SolarScope-style): Not implemented (needs clarification). This seems to refer to a visual indicator (perhaps on a calendar or chart) highlighting days when content was generated (green) vs. days when cached content was reused (red), possibly to track API usage efficiency. It’s a specialized UI idea likely inspired by tools that show resource usage. Currently, no such visualization exists in the app. There is no code referencing a calendar heatmap or usage calendar. The admin usage page is a simple table, and the main calendar (for Sonarr) is unrelated to usage. This item is outstanding and would need further clarification on design. It might be a lower priority visualization to give the developer insight into days heavy with AI generation (hence cost) versus days mostly serving cached results (savings).
	•	Add dark mode toggle: Not implemented. There is no mention of a dark theme or toggle button in the UI templates or CSS. The interface at present likely only has a default light theme. Implementing a dark mode would involve adding alternate styles and a switch (with possibly some JavaScript to remember the preference). This remains a to-do; no progress on this is evident in the current code.
	•	Add simple authentication system (e.g., Plex user + shared password): Not implemented. The app does not have any authentication or user login mechanism yet. All pages and endpoints are accessible without login. The idea of using a Plex username and a shared password suggests a basic auth where perhaps knowledge of a particular credential grants access (possibly to restrict the app to friends/family). No such system exists currently. In code, there are no user accounts or password checks. This task remains open. (Notably, the Plex webhook does log a Plex username with each event, but that is just for record-keeping and is not used for authentication).
	•	Track personal watch history per user: Partially implemented. Through the Plex webhook, the app is already recording each watch event along with the Plex username. This means the raw data for a user’s watch history is being collected (in the webhook_log table). However, there is no front-end feature for a user to view their own history, and no concept of user accounts yet to attach that history to an authenticated session. If the plan is to eventually allow each user to log in and see their watch history or use it in the app, additional work is needed: implementing user identity, filtering history by user, and creating UI for it. At this stage, the data collection part of this feature is underway (for any Plex user who triggers the webhook), but the user-facing functionality is not present.
	•	Let users set their own spoiler limit thresholds: Not implemented. Currently, the spoiler threshold (up to which episode a summary will include events) can be specified on each query but isn’t stored per user. This to-do suggests a feature where a user could set a profile preference like “I’ve seen up to Season X” for a show, and have the app always default to that. Implementing this would require user accounts or at least a client-side memory of preferences. None of that exists yet. As a stopgap, the Plex integration is intended to automatically adjust context, but a manual user setting is not available. Therefore, this task is still open.
	•	Use chat UI libraries to create a messenger-style interface: Not implemented. The current chat with character page (chat_as_character.html) is functional but rudimentary – it shows a form and the reply, without advanced styling or interactive conversation elements. A messenger-style interface would involve styling the conversation as bubbles, possibly supporting a continuous back-and-forth chat log. No such library (like a pre-built chat UI component) has been integrated yet. The front-end would need significant enhancement to achieve this look and feel. As of now, the chat feature resets on each page load (it doesn’t maintain dialogue state) and has basic styling. This improvement remains to be done.
	•	Add character chat mode: “Chat with [Character]” using limited context: Basic version present, needs expansion. The app does allow the user to initiate a chat with a specific character (the form lets you choose a character and show). The underlying functionality chat_as_character() uses a prompt that does not include context beyond the instruction to act in character. A more advanced version might feed in some known details or recent events as context (limited to what the user has seen, to avoid spoilers). This isn’t implemented – the current chat mode is essentially one-turn conversations with no memory or additional context beyond the character’s identity. So while the feature exists in a minimal form, it could be enhanced by incorporating character background context (e.g., a brief summary of the character up to the spoiler limit) into the prompt, and by maintaining state over multiple messages. Those enhancements are not in place yet.
	•	Add chat UI for general Q&A about a show, character, or episode: Not implemented. Aside from the character-specific chat, there is no separate Q&A interface. A general Q&A would allow the user to ask questions like “What happened in Season 2 of X?” or “How are Character A and B related?” and get an answer from the AI using the show’s data. This would require different prompt handling and possibly more context integration (maybe pulling facts from summaries or external sources). There is no evidence of such a mode in the current code. This remains a future enhancement idea, unstarted so far.

Tasks Needing Clarification: A few of the above items stand out as requiring further clarification before implementation, either because they are vaguely defined or seem out of scope:
	•	OpenAI prompt enrichment system (title/description/quantity/mass): as noted, the purpose of this feature is unclear in the TV show context and might need redefinition or could be dropped if it pertains to a different domain.
	•	JSON route links for Shortcuts: the specific requirements here (which routes, for what data, for which external tool) should be clarified in order to implement effectively.
	•	SolarScope-style calendar indicators: the team would need to define what exactly is being conveyed (distinguishing content generation vs. cache use) and how it should look in the UI.
	•	Chat Q&A mode: defining the scope of “general Q&A” (whether it should rely on cached info only, allow spoilers or not, etc.) would help guide development for this feature.

⸻

Conclusion: The ShowNotes app is partially developed with many core features already in place (character summaries, actor overlap comparisons, basic chat, metadata integration, and logging). The architecture is sound, and the README’s outlined design is largely reflected in the codebase. A number of planned enhancements (especially on the front-end and user experience side) remain to be completed. Prioritizing the remaining TODO items – particularly improving the UI (autocomplete, calendar, chat interface), implementing user personalization (authentication and spoiler preferences), and polishing integrations (Sonarr calendar, admin dashboards) – will drive the project toward a more complete and user-friendly state.